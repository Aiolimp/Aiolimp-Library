Vue常见面试题整理
===

[TOC]


### 1. MVVM

MVVM(Model-View-ViewModel), 源自于经典的 Model–View–Controller（MVC）模式。MVVM 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，此时开发者只需要关注业务逻辑，不需要手动操作DOM。

### 2.**说** mvvm **和** mvc **区别？它和其它框架（**jquery**）的区别是什么**? 

mvc 中 Controller 演变成mvvm 中的 ViewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 

和jquery的区别：jQuery是使用选择器（ `$` ）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：`$("lable").val();` ,它还是依赖DOM元素的值。Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，他们通过Vue对象的viewModel实现相互的绑定。这就是传说中的MVVM。

### 3.vue优点？

- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 `kb` ；
- 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
- 双向数据绑定：保留了 `angular` 的特点，在数据操作方面更为简单；
- 组件化：保留了 `react` 的优点，实现了 `html` 的封装和重用，在构建单页面应用方面有着独特的优势；
- 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
- 虚拟DOM：`dom` 操作是非常耗费性能的， 不再使用原生的 `dom` 操作节点，极大解放 `dom` 操作，但具体操作的还是 `dom` 不过是换了另一种方式；
- 运行速度更快：相比较于 `react` 而言，同样是操作虚拟 `dom` ，就性能而言， `vue` 存在很大的优势。

### 4. **为什么说** vue **是一个渐进式框架**? 

vue采用了MVVM模式，自己拥有一套完整的生态系统，可以添加Vuex，vuerouter，也可以添加别的第三方库，并且是相互独立的，可以根据不同的需求选择不同的层级，所以它是轻量级的，渐进式的框架。

### 5.`<keep-alive>` 的作用是什么?

如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keepalive 组件包裹需要保存的组件。用keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行
deactivated 钩子函数，缓存渲染后会执行 actived 钩子函数。

### 6.说出几种vue当中的指令和它的用法？

`v-model` 双向数据绑定；

`v-for` 循环；

`v-if` `v-show` 显示与隐藏；

`v-on` 事件；

`v-once` : 只绑定一次。

`v-cloak`:和和 CSS 规则如 `[v-cloak] { display: none }`一起使用，影藏未编译的标签。

`v-text`:更新文本

`v-html:`更新innerHtml

`v-else:`

`v-slot:` 在<template> 中使用插槽

`v-pre:`  显示标签，跳过没有指令的节点，加快编译。

`v-bind:` 动态绑定多个值

### **7.vue-loader是什么？使用它的用途有哪些？**

vue 文件的一个加载器，将 `template/js/style` 转换成 `js` 模块。

用途：`js` 可以写 `es6` 、 `style`样式可以 `scss` 或 `less` 、 `template` 可以加 `jade`等

### **8.请说出vue.cli项目中src目录每个文件夹和文件的用法？**

`assets` 文件夹是放静态资源；`components` 是放组件；`router` 是定义路由相关的配置;  `app.vue` 是一个应用主组件；`main.js` 是入口文件。

### 9.vue常用修饰符

**v-model 修饰符：** 

.lazy：输入框改变，这个数据就会改变，这个修饰符会在光标离开 input 框才会更新数据

.number：营先输入数字就会限制输入只能是数字，先字符串就相当于没有加 number，注

意，不是输入框不能输入字符串，是这个数据是数字

.trim：输入框过滤首尾的空格

**事件修饰符：** 

.stop：阻止事件冒泡，相当于调用了 event.stopPropagation()方法

.prevent：阻止默认行为，相当于调用了 event.preventDefault()方法，比如表单的提交、

a 标签的跳转就是默认事件

.self：只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个 div

里面有个按钮，div 和按钮都有事件，我们点击按钮，div 绑定的方法也会触发，如果 div

的 click 加上 self，只有点击到 div 的时候才会触发，变相的算是阻止冒泡

.once：事件只能用一次，无论点击几次，执行一次之后都不会再执行

.capture：事件的完整机制是捕获-目标-冒泡，事件触发是目标往外冒泡

.sync：对 prop 进行双向绑定

.keyCode：监听按键的指令，具体可以查看 vue 的键码对应表

### **10.分别简述computed和watch的使用场景**

- `computed` : 当一个属性受多个属性影响的时候就需要用到 `computed` ，最典型的栗子：购物车商品结算的时候
- `watch` : 当一条数据影响多条数据的时候就需要用 `watch` ，栗子：搜索数据

### 11.vue组件中data为什么必须是一个函数

因为 JavaScript 的特性所导致，在 `component` 中，`data` 必须以函数的形式存在，不可以是对象。组件中的 `data` 写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 `data` ，每个 vue 组件的实例都有自己的作用域，互不干扰。而单纯的写成对象形式，就是所有的组件实例共用了一个 `data`的内存地址 ，这样改一个数据其他都改变。

### 12.单页面应用和多页面应用区别及优缺点

单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。

多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新

单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。

单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。

### 13.assets和static的区别

**相同点：** `assets` 和 `static` 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点

**不相同点：**`assets` 中存放的静态资源文件在项目打包时，也就是运行 `npm run build` 时会将 `assets` 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 `static` 文件中跟着 `index.html` 一同上传至服务器。`static` 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 `static` 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 `assets` 中打包后的文件提交较大点。在服务器中就会占据更大的空间。

**建议：** 将项目中 `template`需要的样式文件js文件等都可以放置在 `assets` 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如`iconfoont.css` 等文件可以放置在 `static` 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。

### 14.Vue-router跳转和location.href有什么区别

使用 `location.href= /url `来跳转，简单方便，但是刷新了页面

引进 router ，然后使用 `router.push( /url )` 来跳转，使用了 `diff` 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 `history.pushState()` 没什么差别的，因为vue-router就是用了 `history.pushState()` ，尤其是在history模式下。

### 15.请说下封装 vue 组件的过程？

1. 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。　
2. 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。　　
3. 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。　　
4. 封装完毕了，直接调用即可

### 16.params和query的区别

用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 `this.$route.query.name` 和 `this.$route.params.name` 。url地址显示：query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示

注意点：query刷新不会丢失query里面的数据 params刷新 会 丢失 params里面的数据。

- router为VueRouter实例，想要导航到不同URL，则使用router.push方法
- $route为当前router跳转对象，里面可以获取name、path、query、params等

### **17.vue更新数组时触发视图更新的方法**

push()；pop()；shift()；unshift()；splice()；sort()；reverse()

### 18.简述每个周期具体适合哪些场景

**beforeCreate：** 在beforeCreate生命周期执行的时候，挂载元素$el、data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法

**create：** 挂载元素$el还没有初始化，data 和 methods都已经被初始化好了，可以要调用 methods 中的方法，或者操作 data 中的数据，

**beforeMount：** 执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的

**mounted：** 执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行

**beforeUpdate：** 当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步

**updated：** 页面显示的数据和data中的数据已经保持同步了，都是最新的

**beforeDestory：** Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁

**destroyed：** 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。

### 18.created和mounted的区别

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。

mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。
---
