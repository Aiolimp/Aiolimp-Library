### 1.HTTP 报文结构和特点

http是一种超文本传输语言，他的请求报文是由**起始行、头部、空行和实体**组成。

对于请求报文来说，它的起始行是由**方法+路径+http版本**组成。

对于响应报文，起始行是由**http版本+状态码+原因**组成。

空行用来区分头部和实体。

**http特点：**

- 灵活可拓展，没有严格的语法限制，传输形式多样性。
- 基于TCP/IP协议，传输可靠。
- 请求-应答。客户端和服务端一发一收、有来有回。
- 无状态，每次http请求不用保留状态信息。

**缺点：**

- 需要保存大量上下文信息的时候，此时无状态就是缺点了
- 明文传输，不安全
- 队头阻塞，对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是`HTTP队头阻塞`问题。通过并发连接(增加任务队列)和域名分片(将一个域名分为多个二级域名，但他们最终指向的还是同一个服务器)解决。

### 2. HTTP 常用的请求方式，区别和用途？

**GET**: 发送请求，获取服务器数据

**POST**：向URL指定的资源提交数据

**PUT**：向服务器提交数据，以修改数据

**HEAD**:请求页面的首部，获取资源的元信息

**DELETE**：删除服务器上的某些资源。

**CONNECT**：建立连接隧道，用于代理服务器；

**OPTIONS**：列出可对资源实行的请求方法，常用于跨域

**TRACE**：追踪请求-响应的传输路径

### 3.GET 和 POST 有什么区别？

1.GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会

2.GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。

3.get传递数据受浏览器限时，post不会

### 3.理解URI

**URI**, 全称为(Uniform Resource Identifier), 也就是**统一资源标识符**，它的作用很简单，就是区分互联网上不同的资源。

但是，它并不是我们常说的`网址`, 网址指的是`URL`, 实际上`URI`包含了`URN`和`URL`两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。

#### URI 的结构

URI 真正最完整的结构是这样的。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd677629b70d~tplv-t2oaga2asx-watermark.awebp)

**scheme** 表示协议名，比如`http`, `https`, `file`等等。后面必须和`://`连在一起。

**user:passwd**@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。

**host:port**表示主机名和端口。

**path**表示请求路径，标记资源所在位置。

**query**表示查询参数，为`key=val`这种形式，多个键值对之间用`&`隔开。

**fragment**表示 URI 所定位的资源内的一个**锚点**，浏览器可以根据这个锚点跳转到对应的位置。

举个例子:

```
https://www.baidu.com/s?wd=HTTP&rsv_spt=1
```

这个 URI 中，`https`即`scheme`部分，`www.baidu.com`为`host:port`部分（注意，http 和 https 的默认端口分别为80、443），`/s`为`path`部分，而`wd=HTTP&rsv_spt=1`就是`query`部分。

### 4.HTTP 状态码？

RFC 规定 HTTP 的状态码为**三位数**，被分为五类:

- **1xx**: 表示目前是协议处理的中间状态，还需要后续操作。
- **2xx**: 表示成功状态。
- **3xx**: 重定向状态，资源位置发生变动，需要重新请求。
- **4xx**: 请求报文有误。
- **5xx**: 服务器端发生错误。

接下来就一一分析这里面具体的状态码。

>101 切换请求协议，从 HTTP 切换到 WebSocket
>
>200 请求成功，表示正常返回信息。
>
>301 永久重定向，会缓存
>
>302 临时重定向，不会缓存
>
>304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
>
>400 请求错误
>
>401——请求未经授权
>
>403 服务器禁止访问
>
>404 找不到与 URI相匹配的资源。
>
>500 常见的服务器端错误
>
>503——服务不可用

###  5.Accept 字段

- 数据格式

  通过浏览器支持的MIME，来将数据类型体现在`Content-type`和`Accept`上，并且请求头部的Accept和响应头部的`Content-type`是相匹配的。

- 压缩方式

  对接收到的数据进行压缩，采取什么压缩方式体现在发送方的`Content-Encoding`上，接受什么样的方式体现在接收方的`Accept-Encoding`上。

  - `gzip:` 当今最流行的压缩格式

  - `deflate`: 另外一种著名的压缩格式

  - `br`: 一种专门为 HTTP 发明的压缩算法

    ```js
    // 发送端
    Content-Encoding: gzip
    // 接收端
    Accept-Encoding: gzip
    ```

- 支持语言

  发送方`Content-language`来决定支持的语言，对应接受方的`Accept-language`

- 字符集

  发送端没有`Content-Charset`，而是直接放在`Content-type`中，对应接受端的`Accept-Charset`

### 6.对于定长和不定长的数据，http怎么进行传输

对于定长的数据包而言，在发送数据过程中，可以设置`Content-Length`来指定发送的长度。但是设置不当也会导致传输失败。

对于不定长数据可以使用头部字段的`Transfer-Encoding：chunked`，设置了这个字段，`Content-Length`字段则会被忽视，并且基于长链接持续推送动态内容。

### 7.HTTP 如何处理大文件的传输？

通过加上响应头`Accept-Ranges：none`，来设置范围请求。

### 8.HTTP1.1 如何解决 HTTP 的队头阻塞问题？

#### 队头阻塞

HTTP 传输是基于`请求-应答`的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的`HTTP队头阻塞`问题。

### 并发连接

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。

### 域名分片

比如 `content1.Aiolimp.com` 、`content2.Aiolimp.com`。

这样一个`Aiolimp.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

### 11.http和https区别

http是明文传输的，相对来不安全，https增加了一层SSL/TLS协议，建立ssl连接和TLS握手，确保接下来的通信都是加密的，无法被轻易截取。

大致流程：客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个**「对称加密的秘钥」**，使用**「该公钥」**加密，传输给服务端，服务端再通过解密拿到该**「对称秘钥」**，后续的所有信息都通过该**「对称秘钥」**进行加密解密，完成整个HTTPS的流程。最后通过数字证书认证的方式，让传输过程安全性大大提高。

### 12.http代理

- 负载均衡：客户端的请求只会先达到代理服务器，然后由代理服务器来转发请求到真实的服务器上，通过各种算法让服务器的负载尽量平均。
- 保障安全
- 通过缓存代理，将缓存内容缓存到代理服务器，使得客户端之间从代理服务器获取数据，而不时源服务器。

### 13.浏览器缓存

强缓存：

强缓存阶段不用发送http请求，通过Expries和Cache-Contorl来检查强缓存。

Expries存在于服务端返回的响应头中，通过设置过期时间，告诉浏览器，在这个时间之前可以通过缓存获取数据，但是这个时间可能会不准确在http1.1后不在使用，而是通过Cache-Contorl字段，通过设置过期时长，也就是max-age来控制缓存。其次也包括其他的指令，如private、no-cache(跳过强缓存直接协商缓存)、no-store（直接不缓存）等等，当强缓存失效时，这时进入协商缓存。

协商缓存：

协商缓存通过浏览器请求头携带的缓存tag决定是否使用缓存。分为Last-Modified和ETag两种。last-Modified即最后修改时间，通过修改的时间进行对比，ETag是通过文件标识进行对比，通过结果是否返回304告诉浏览器是否使用缓存。

协商缓存发送http请求，服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`这些请求字段检查资源是否更新，若资源更新，则返回资源和200状态码，否则返回304告诉浏览器是否使用缓存。

缓存位置：

Service Worker(离线缓存)、Memory Cache(内存缓存)、 Disk Cache(磁盘缓存)、Push Cache(推送缓存)

### 14.浏览器本地存储

cookie是浏览器的一种本地存储方式，常用来进行身份校验，内部以键值对的形式存储，向同一个域名发送请求都会携带相同的cookie，服务器拿到cookie进行解析，便能拿到客户端的状态。

缺陷：

1.容量小，只有4kb。

2.安全缺陷，Cookie以文本形式进行传递，容易被存篡改。

3.性能缺陷。cookie紧跟域名，不管域名需不需要都会携带，请求增多，浪费性能。

localStorage：

是一种持续化存储。应用场景：存储稳定的资源，如logo，图片等等。

1.容量上线为5M，比cookie大很多。

2.只存在于客户端，默认不参与和服务端的通信，避免了cookie带来的性能问题和安全问题。

3.接口封装，通过localStorage暴露在全局，可以通过setItem和getItem方法进行操作。

sessionStorage：

是会话级别的存储，不是持续化存储，会话结束也就是页面关闭，sessionStorage就不存在了。可以用他来存储本次浏览记录。

IndexedDB

IndexedDB是存在于浏览器中的非关系型数据库，为大型数据提供存储接口。

### 15.从输入URL到页面加载呈现了什么？

1.浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。

2.TCP三次握手：

第一次握手由浏览器发起，告诉客户端要准备发送请求了。

第二次握手由服务器发起，告诉浏览器准备接受了。

第三次握手由浏览器发起，开始发送请求。

三次握手的目的就是防止已失效的连接请求报文突然传回服务端而产生错误。

3.发送HTTP请求报文，请求报文携带请求行、请求头和请求体。

4.服务器处理请求并返回HTTP响应报文报文，响应报文也有响应行、响应头和响应体三部分。

5.浏览器解析渲染界面

- 根据html解析DOM树
- 根据CSS解析成CSS规则树
- 结合DOM树和CSS规则树，生成渲染树
- 根据渲染树，计算每个节点的布局信息
- 根据计算好的信息绘制页面

6.数据传输完毕，断开连接，TCP四次挥手

第一次挥手由浏览器发起，告诉服务器请求报文发送完毕。

第二次挥手由服务器发起告诉浏览器，请求报文接受完毕。

第三次挥手由服务器发起，告诉浏览器，响应报文以发送。

第四次挥手由浏览器发起，告诉服务器响应报文接收完毕，准备断开连接。

### 16.XSS攻击

xss (Cross Site Scripting),XSS攻击是指浏览器中执行恶意脚本，从而拿到用户信息进行操作。

如：

- 窃取cookie
- 监听用户行为密码输入登陆行为
- 修改DOM伪造登陆表单
- 在页面中生成浮窗广告

XSS攻击实现方式：

- **存储型**：将恶意脚本存储到服务端数据库，然后在客户端执行这些脚本，达到攻击效果。如评论区提交脚本代码，页面渲染后直接执行。
- **反射型**：将脚本作为网络请求参数，经过服务器反射到html文档中，执行解析。
- **文档型**：不会经过服务端，而是劫持网络数据，修改html文档。

防范措施：

- 不要相信用户的输入
- 利用CSP（服务器决定浏览器加载那些资源）和Cookie的HttpOnly属性使Javascript无法读取cookie的值

### 17.CSRF攻击

CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求.

攻击方式：

- 自动 GET 请求
- 自动 POST 请求
- 诱导点击发送 GET 请求。

预防措施：

- 利用cookie的samsite属性来限制cookie的携带
- 验证来源站点
- CSRF token {% csrf_token %}

### 18.跨域

 首先，浏览器遵循同源策略，即协议、主机和端口都相同则为同源，当浏览器向目标URL发Ajax请求时，如果当前url和目标url不同源则产生跨域。跨域实际上请求以及发送出去了，并且服务端收到请求并正常返回结果，知识被浏览器拦截了。

处理跨域的方法：

1.JSONP

因为script标签是允许跨域加载资源的，所以JSONP利用script的开放策略，通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。JSONP的优点是兼容性好，可以解决主流浏览器跨域访问的问题，缺点是仅支持get方法，具有局限性。

2.CORS

是跨域的根本解决方法，有浏览器自动完成，只要服务器实现了CORS接口，就可以实现跨域通信。当请求发送出去之前，它会自动在请求头中添加一个origin字段，来说明请求来自哪个源，服务器拿到请求之后，在回应时对应地添加`Access-Control-Allow-Origin`字段，如果`Origin`不在这个字段的范围中，那么浏览器就会将响应拦截。因此，`Access-Control-Allow-Origin`字段是服务器用来决定浏览器是否拦截这个响应。

对于复杂请求，就是使用 OPTIONS 方法发送请求，以判断是否有对指定资源的访问权限。

3.Webscoket

他实现了浏览器和服务器之间的双向通信协议，也是一种支持跨域的解决方案。

### 10.**options 方法有什么用？**

用于客户端查看服务器的性能，通过options向服务器发送请求可以测试服务器功能是否正常，并且获取http请求方法。

JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送请求，以判断是否有对指定资源的访问权限。
