### 1.`HTTP` 报文结构和特点

`http`是一种超文本传输语言，他的请求报文是由**起始行、头部、空行和实体**组成。

对于请求报文来说，它的起始行是由**方法+路径+`http`版本**组成。

对于响应报文，起始行是由**`http`版本+状态码+原因**组成。

空行用来区分头部和实体。

**`http`特点：**

- 灵活可拓展，没有严格的语法限制，传输形式多样性。
- 基于`TCP/IP`协议，传输可靠。
- 请求-应答。客户端和服务端一发一收、有来有回。
- 无状态，每次`http`请求不用保留状态信息。

**缺点：**

- 需要保存大量上下文信息的时候，此时无状态就是缺点了
- 明文传输，不安全
- 队头阻塞，对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是`HTTP队头阻塞`问题。通过并发连接(增加任务队列)和域名分片(将一个域名分为多个二级域名，但他们最终指向的还是同一个服务器)解决。

### 2. HTTP 常用的请求方式，区别和用途？

**GET**: 发送请求，获取服务器数据

**POST**：向URL指定的资源提交数据

**PUT**：向服务器提交数据，以修改数据

**HEAD**:请求页面的首部，获取资源的元信息

**DELETE**：删除服务器上的某些资源。

**CONNECT**：建立连接隧道，用于代理服务器；

**OPTIONS**：列出可对资源实行的请求方法，常用于跨域

**TRACE**：追踪请求-响应的传输路径

### 3.`GET` 和 `POST` 有什么区别？

- **请求参数**：GET 把参数包含在 URL 中，用&连接起来；POST 通过 request body 传递参数。
- **请求缓存**：GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- **安全性：**GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- **历史记录**：GET请求参数会被完整保留在浏览历史记录里，而POST中的参数不会被保留。

### 3.理解URI

**URI**, 全称为(Uniform Resource Identifier), 也就是**统一资源标识符**，它的作用很简单，就是区分互联网上不同的资源。

但是，它并不是我们常说的`网址`, 网址指的是`URL`, 实际上`URI`包含了`URN`和`URL`两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。

#### URI 的结构

URI 真正最完整的结构是这样的。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd677629b70d~tplv-t2oaga2asx-watermark.awebp)

**scheme** 表示协议名，比如`http`, `https`, `file`等等。后面必须和`://`连在一起。

**user:passwd**@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。

**host:port**表示主机名和端口。

**path**表示请求路径，标记资源所在位置。

**query**表示查询参数，为`key=val`这种形式，多个键值对之间用`&`隔开。

**fragment**表示 URI 所定位的资源内的一个**锚点**，浏览器可以根据这个锚点跳转到对应的位置。

举个例子:

```
https://www.baidu.com/s?wd=HTTP&rsv_spt=1
```

这个 URI 中，`https`即`scheme`部分，`www.baidu.com`为`host:port`部分（注意，`http` 和 `https` 的默认端口分别为80、443），`/s`为`path`部分，而`wd=HTTP&rsv_spt=1`就是`query`部分。

### 4. URI和URL的区别

- URI，全称是Uniform Resource Identifier)，中文翻译是统一资源标志符，主要作用是唯一标识一个资源。
- URL，全称是Uniform Resource Location)，中文翻译是统一资源定位符，主要作用是提供资源的路径。

打个经典比喻吧，URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。



### 4.`HTTP` 状态码？

- 1xx：接受的请求正在处理 （信息性状态码）
- 2xx：表示请求正常处理完毕 （成功状态码）
- 3xx：表示重定向状态，需要重新请求 （重定向状态码）
- 4xx：服务器无法处理请求 （客户端错误状态码）
- 5xx：服务器处理请求出错 （服务端错误状态码）

**常用状态码如下：**

>101 切换请求协议，从 HTTP 切换到 WebSocket
>
>200 请求成功，表示正常返回信息。
>
>301 永久重定向，会缓存
>
>302 临时重定向，不会缓存
>
>304 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
>
>400 请求错误
>
>401 请求未经授权
>
>403 服务器禁止访问
>
>404 找不到与 URI相匹配的资源。
>
>500 常见的服务器端错误
>
>503 服务不可用

###  5.`Accept` 字段

- 数据格式

  通过浏览器支持的MIME，来将数据类型体现在`Content-type`和`Accept`上，并且请求头部的Accept和响应头部的`Content-type`是相匹配的。

- 压缩方式

  对接收到的数据进行压缩，采取什么压缩方式体现在发送方的`Content-Encoding`上，接受什么样的方式体现在接收方的`Accept-Encoding`上。

  - `gzip:` 当今最流行的压缩格式

  - `deflate`: 另外一种著名的压缩格式

  - `br`: 一种专门为 HTTP 发明的压缩算法

    ```js
    // 发送端
    Content-Encoding: gzip
    // 接收端
    Accept-Encoding: gzip
    ```

- 支持语言

  发送方`Content-language`来决定支持的语言，对应接受方的`Accept-language`

- 字符集

  发送端没有`Content-Charset`，而是直接放在`Content-type`中，对应接受端的`Accept-Charset`

### 6.对于定长和不定长的数据，`http`怎么进行传输

对于定长的数据包而言，在发送数据过程中，可以设置`Content-Length`来指定发送的长度。但是设置不当也会导致传输失败。

对于不定长数据可以使用头部字段的`Transfer-Encoding：chunked`，设置了这个字段，`Content-Length`字段则会被忽视，并且基于长链接持续推送动态内容。

### 7.`HTTP` 如何处理大文件的传输？

通过加上响应头`Accept-Ranges：none`，来设置范围请求。

### 8.`HTTP1.1` 如何解决 HTTP 的队头阻塞问题？

**队头阻塞**

HTTP 传输是基于`请求-应答`的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的`HTTP队头阻塞`问题。

**并发连接**

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。

**域名分片**

比如 `content1.Aiolimp.com` 、`content2.Aiolimp.com`。

这样一个`Aiolimp.com`域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

### 9.`http`和`https`区别

HTTP，超文本传输协议，英文是**Hyper Text Transfer Protocol**，是一个基于TCP/IP通信协议来传递数据的协议。HTTP存在这**几个问题**：

- 请求信息明文传输，容易被窃听截取。
- 数据的完整性未校验，容易被篡改
- 没有验证对方身份，存在冒充危险

`HTTPS`就是为了解决HTTP存在问题的。`HTTPS`，英文是`HyperText Transfer Protocol over Secure Socket Layer`，可以这么理解`Https`是身披`SSL`(Secure Socket Layer)的HTTP，即**`HTTPS` 协议 = `HTTP+SSL/TLS`**。通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的传输数据进行**加密**。

大致流程：客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个**「对称加密的秘钥」**，使用**「该公钥」**加密，传输给服务端，服务端再通过解密拿到该**「对称秘钥」**，后续的所有信息都通过该**「对称秘钥」**进行加密解密，完成整个`HTTPS`的流程。最后通过数字证书认证的方式，让传输过程安全性大大提高。

它们主要区别：

- 数据是否加密: `Http` 是明文传输，`HTTPS`是密文
- 默认端口: `Http`默认端口是80，`Https`默认端口是443
- 资源消耗：和HTTP通信相比，`Https`通信会消耗更多的CPU和内存资源，因为需要加解密处理；
- 安全性: `http`不安全，`https`比较安全。

### 10.`HTTP` 1.0，1.1，2.0 的版本区别

**HTTP 1.0**

- HTTP 1.0规定浏览器与服务器只保持**短暂的连接**，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。它也可以强制开启长链接，例如设置`Connection: keep-alive` 这个字段

**HTTP 1.1**

- 引入了长连接，即**TCP连接默认不关闭，可以被多个请求复用**。
- 引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。
- 缓存处理，引入了更多的缓存控制策略，如`Cache-Control`、`Etag/If-None-Match`等。
- 错误状态管理，新增了24个错误状态响应码，如409表示请求的资源与资源的当前状态发生冲突。

**HTTP 2**

- 采用了**多路复用**，即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。
- 服务端推送，HTTP 2允许服务器未经请求，主动向客户端发送资源

### 11.说下计算机网络体系结构

计算机网路体系结构主要有`ISO`七层模型、`TCP/IP` 四层模型、五层体系结构。

**ISO七层模型**

ISO七层模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。

- 应用层：网络服务与最终用户的一个接口，协议有：**HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP**
- 表示层：数据的表示、安全、压缩。
- 会话层：建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话
- 传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：**TCP UDP，数据包一旦离开网卡即进入网络传输层**
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：**ICMP IGMP IP（IPV4 IPV6）**
- 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。
- 物理层：建立、维护、断开物理连接。

**TCP/IP 四层模型**

- 应用层：对应于ISO参考模型的（应用层、表示层、会话层），为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等
- 传输层:对应ISO的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。定义了TCP和UDP两层协议。
- 网际层：对应于ISO参考模型的网络层，主要解决主机到主机的通信问题。三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）
- 网络接口层：与ISO参考模型的数据链路层、物理层对应。它负责监视数据在主机和网络之间的交换。

**五层体系结构**

- 应用层：通过应用进程间的交互来完成特定网络应用。对应于OSI参考模型的（应用层、表示层、会话层），应用层协议很多，如**域名系统DNS**，HTTP协议，支持电子邮件的 **SMTP协议**等等。我们把应用层交互的数据单元称为报文。
- 传输层：负责向两台主机进程之间的通信提供通用的数据传输服务。对应OSI参考模型的传输层，协议有传输控制协议 TCP 和 用户数据协议 UDP。
- 网络层：对应ISO参考模型的的网络层
- 数据链路层：对应ISO参考模型的的数据链路层
- 物理层：对应ISO参考模型的的物理层层。在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。



### **12.`HTTP` 如何实现长连接？**

- HTTP分为长连接和短连接，其实**本质上说的是TCP的长短连接**。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一个说法。
- 长连接是指的是TCP连接，而不是HTTP连接。
- TCP 长连接可以复用一个TCP连接来发起多次HTTP请求，这样可以减少资源消耗，比如一次请求HTML，短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接，在响应头设置**Connection为keep-alive**，HTTP1.1 默认是长连接，而HTTP 1.0协议也支持长连接，但是默认是关闭的。

### 13.Https 流程是怎样的？

HTTPS = HTTP + SSL/TLS，即用SSL/TLS对数据进行加密和解密，Http进行传输。

SSL，即Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。

TLS，即Transport Layer Security(安全传输层协议)，它是SSL 3.0的后续版本。

1. 用户在浏览器里输入一个https网址，然后连接到server的443端口。
2. 服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过。这套证书其实就是一对公钥和私钥。
3. 服务器将自己的数字证书（含有公钥）发送给客户端。
4. 客户端收到服务器端的数字证书之后，会对其进行检查，如果不通过，则弹出警告框。如果证书没问题，则生成一个密钥（对称加密），用证书的公钥对它加密。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。
7. 服务器将加密后的密文返回给客户端。
8. 客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数据。

用户在浏览器输入https网址，连接到服务器端口。服务器将自己含有公钥的数字证书发送给客户端。客户端收到数字证书后对其进行检查，检查不通过弹出警告。证书没问题则生产一个对称加密秘钥，用证书的公钥对它加密。客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。服务器将加密后的密文返回给客户端。客户端收到服务器发返回的密文，用自己的密钥对其进行对称解密，得到服务器返回的数据。

### 14.对称加密与非对称加密有什么区别

- **对称加密**：加密和解密使用相同密钥的加密算法。

- **非对称加密：**非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。



### 12.`http`代理

- 负载均衡：客户端的请求只会先达到代理服务器，然后由代理服务器来转发请求到真实的服务器上，通过各种算法让服务器的负载尽量平均。
- 保障安全
- 通过缓存代理，将缓存内容缓存到代理服务器，使得客户端之间从代理服务器获取数据，而不时源服务器。

### 13.浏览器缓存

强缓存：

强缓存阶段不用发送http请求，通过Expries和Cache-Contorl来检查强缓存。

Expries存在于服务端返回的响应头中，通过设置过期时间，告诉浏览器，在这个时间之前可以通过缓存获取数据，但是这个时间可能会不准确在http1.1后不在使用，而是通过Cache-Contorl字段，通过设置过期时长，也就是max-age来控制缓存。其次也包括其他的指令，如private、no-cache(跳过强缓存直接协商缓存)、no-store（直接不缓存）等等，当强缓存失效时，这时进入协商缓存。

协商缓存：

协商缓存通过浏览器请求头携带的缓存tag决定是否使用缓存。分为Last-Modified和ETag两种。last-Modified即最后修改时间，通过修改的时间进行对比，ETag是通过文件标识进行对比，通过结果是否返回304告诉浏览器是否使用缓存。

协商缓存发送http请求，服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`这些请求字段检查资源是否更新，若资源更新，则返回资源和200状态码，否则返回304告诉浏览器是否使用缓存。

缓存位置：

Service Worker(离线缓存)、Memory Cache(内存缓存)、 Disk Cache(磁盘缓存)、Push Cache(推送缓存)

### 14.浏览器本地存储

cookie是浏览器的一种本地存储方式，常用来进行身份校验，内部以键值对的形式存储，向同一个域名发送请求都会携带相同的cookie，服务器拿到cookie进行解析，便能拿到客户端的状态。

缺陷：

1.容量小，只有4kb。

2.安全缺陷，Cookie以文本形式进行传递，容易被存篡改。

3.性能缺陷。cookie紧跟域名，不管域名需不需要都会携带，请求增多，浪费性能。

localStorage：

是一种持续化存储。应用场景：存储稳定的资源，如logo，图片等等。

1.容量上线为5M，比cookie大很多。

2.只存在于客户端，默认不参与和服务端的通信，避免了cookie带来的性能问题和安全问题。

3.接口封装，通过localStorage暴露在全局，可以通过setItem和getItem方法进行操作。

sessionStorage：

是会话级别的存储，不是持续化存储，会话结束也就是页面关闭，sessionStorage就不存在了。可以用他来存储本次浏览记录。

IndexedDB

IndexedDB是存在于浏览器中的非关系型数据库，为大型数据提供存储接口。

### 15.从输入URL到页面加载呈现了什么？

总体来说分为以下几个过程:

- `DNS` 解析:将域名解析成 `IP` 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手

1.浏览器通过向 `DNS` 服务器发送域名，`DNS` 服务器查询到与域名相对应的 `IP` 地址，然后返回给浏览器，浏览器再将 `IP` 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。

>`DNS`查找过程：浏览器缓存、路由缓存、`DNS`缓存、通过`DNS`服务器查找`ip`、向跟服务器发送请求进行递归查询

2.`TCP`三次握手：

>第一次握手：客户端发送网络包，服务端收到了。
>
>这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
>
>第二次握手：服务端发包，客户端收到了。
>
>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
>
>第三次握手：客户端发包，服务端收到了。
>
>这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
>
>因此，需要三次握手才能确认双方的接收与发送能力是否正常。

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备

3.发送HTTP请求报文，请求报文携带请求行、请求头和请求体。

4.服务器处理请求并返回HTTP响应报文报文，响应报文也有响应行、响应头和响应体三部分。

5.浏览器解析渲染界面

- 根据`html`解析`DOM`树
- 根据`CSS`解析成`CSS`规则树
- 结合`DOM`树和`CSS`规则树，生成渲染树
- 根据渲染树，计算每个节点的布局信息
- 根据计算好的信息绘制页面

6.数据传输完毕，断开连接，TCP四次挥手

第一次挥手由浏览器发起，告诉服务器请求报文发送完毕。

第二次挥手由服务器发起告诉浏览器，请求报文接受完毕。

第三次挥手由服务器发起，告诉浏览器，响应报文以发送。

第四次挥手由浏览器发起，告诉服务器响应报文接收完毕，准备断开连接。

详细参考：[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)

​                   [复习一下：从URL输入到页面展现到底发生什么](https://mp.weixin.qq.com/s/ipPcKG5ffNMARM8bcGwxDg)

### 16. 了解下DNS，解析过程？

DNS，**domain name system**，域名解析系统，是因特网上作为域名和IP地址相互映射的一个分布式数据库。它的作用非常简单，就是可以根据域名查出对应的IP地址。

解析过程如下：

1. 首先，检查**浏览器缓存**中，查找对应的IP地址，找到就直接返回；否则下一步。
2. 将请求发送给**本地DNS服务器**，在本地DNS服务器缓存中查询，如果查找到就直接返回，否则下一步；
3. 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会告诉本地DNS服务器去查询**哪个顶级域名服务器**。
4. 本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地DNS服务器，去查找**哪个权限域名服务器**。
5. 本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器请求域名所对应的IP地址。
6. 最后，本地域名服务器告诉主机**请求域名**所对应的IP地址。

### 16.请详细介绍一下TCP 的三次握手机制

![TCP三次握手](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7eb38a6e24f64c78b6fe5e49ba6a8c0c~tplv-k3u1fbpfcp-watermark.awebp)

开始客户端和服务器都处于 CLOSED 状态，然后服务端开始监听某个端口，进入 LISTEN 状态

- 第一次握手(SYN=1, seq=x)，发送完毕后，客户端进入 SYN_SEND 状态
- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端进入 SYN_RCV状态。
- 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时

### 17.TCP四次挥手过程?

![TCP四次挥手过程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/999957de66e746998b6b5ccfe0b15aaf~tplv-k3u1fbpfcp-watermark.awebp)

###  18.TCP四次挥手过程中，客户端为什么需要等待 2MSL,才进入CLOSED状态

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/568a9da479bc4d8bbbb3c5534270206b~tplv-k3u1fbpfcp-watermark.awebp)

2MSL，2 Maximum Segment Lifetime，即两个最大段生命周期

> - 1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端
> - 1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达

### 19.TCP 是如何保证可靠性的

- 首先，TCP的连接是基于**三次握手**，而断开则是**四次挥手**。确保连接和断开的可靠性。

- 其次，TCP的可靠性，还体现在**有状态**;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。

- 再次，TCP的可靠性，还体现在**可控制**。它有数据包校验、ACK应答、**超时重传(发送方)**、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

### 20. TCP 和 UDP 的区别

1. TCP面向连接（（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
2. TCP要求安全性，提供可靠的服务，通过TCP连接传送的数据，不丢失、不重复、安全可靠。而UDP尽最大努力交付，即不保证可靠交付。
3. TCP是点对点连接的，UDP一对一，一对多，多对多都可以
4. TCP传输效率相对较低,而UDP传输效率高，它适用于对高速传输和实时性有较高的通信或广播通信。
5. TCP适合用于网页，邮件等;UDP适合用于视频，语音广播等
6. TCP面向字节流，UDP面向报文

### 21. WebSocket与socket的区别

- Socket = IP地址 + 端口 + 协议。

> 具体来说，Socket是一套标准，它完成了对TCP/IP的高度封装，屏蔽网络细节以方便开发者更好地进行网络编程。

- WebSocket是一个持久化的协议，它是伴随HTTP5而出的协议，用来解决**http不支持持久化连接**的问题。
- Socket一个是**网编编程的标准接口**，而WebSocket是应用层通信协议。

### 16.XSS攻击

XSS 攻击，全称**跨站脚本攻击（Cross-Site Scripting）**，它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。XSS攻击一般分三种类型：**存储型 、反射型 、DOM型XSS**

XSS攻击实现方式：

- **存储型**：将恶意脚本存储到服务端数据库，然后在客户端执行这些脚本，达到攻击效果。这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。
- **反射型**：攻击者构造出包含恶意代码的URL，用户 URL 时，服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。如网站搜索、跳转等。
  - **DOM 型 XSS**：不会经过服务端，而是前端 JavaScript 取出 URL 中的恶意代码并执行。

防范措施：

- 不相信用户的输入，对输入进行过滤，过滤标签等，只允许合法值。
- 利用HTML 转义。
- 对于链接跳转，如` <a href="xxx"` 等，要校验内容，禁止以script开头的非法链接。通过`.addEventlistener()` 进行事件绑定。
- 限制输入长度等等。
- 避免HTML拼接 

### 17.CSRF攻击

CSRF，跨站请求伪造（英语：Cross-site request forgery），攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。简单点说就是，攻击者盗用了你的身份，以你的名义发送恶意请求。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

攻击方式：

通过图片URL、超链接、CORS、Form提交等等，发送自动的get或者post请求。

特点：

- CSRF（通常）发生在第三方域名。
- CSRF攻击者不能获取到Cookie等信息，只是使用。

预防措施：

- 利用cookie的samsite属性来限制cookie的携带

>Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”
>
>Samesite=Strict设置成严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie。
>
>缺点是兼容性不好

- 同源检测，直接禁止外域（或者不受信任的域名）对我们发起请求。

>判断Origin Header和Referer Header头文件是否存在

- CSRF Token

>   1.首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密。
>
>2. 页面提交的请求携带这个Token
>
>   3.服务器验证Token是否正确

- 双重Cookie验证

### 18.跨域

#### 1.什么是同源策略及其限制内容？

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

**跨域解决方案**

#### **2.jsonp**

利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。

**JSONP优缺点**

JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

**JSONP的实现流程**

- 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
- 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。
- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。
- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。

#### 3.cors

**CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现**。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

##### 1) 简单请求

只要同时满足以下两大条件，就属于简单请求

条件1：使用下列方法之一：

- GET
- HEAD
- POST

条件2：Content-Type 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。

##### 2) 复杂请求

不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

#### 4.websocket

Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

#### 5. Node中间件代理(两次跨域)

实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。** 代理服务器，需要做以下几个步骤：

- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。
- 将 响应 转发给客户端。

#### 6.nginx反向代理

使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

#### 8.总结

- CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案

- JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

- 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。

- 日常工作中，用得比较多的跨域方案是cors和nginx反向代理

### **options 方法有什么用？**

用于客户端查看服务器的性能，通过options向服务器发送请求可以测试服务器功能是否正常，并且获取http请求方法。

JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送请求，以判断是否有对指定资源的访问权限。