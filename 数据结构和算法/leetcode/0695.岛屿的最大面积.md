### 岛屿的最大面积

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

**示例1：**

![img](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)

```
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

**示例2：**

```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

### 思路:

1. 定义岛屿最大数量`maxcount`，某个岛屿数量`count`初始值为0；
1. 遍历二维数组，如果某个值等于`‘1’`，则调用`dfs`函数，传入当前值的坐标，`count`加一。
1. 将传入的坐标值设为`‘0’`，递归检查坐标值上下左右对应的值是否为`‘1’`，如果是，则变成0 ，当前岛屿数量加一。
1. 比较当前岛屿数量和之前的最大岛屿数量，取最大值。

### 代码

```js
var maxAreaOfIsland = function (grid) {
    // 定义最大的岛屿
    let maxcount = 0;
    // 定义某个岛屿的数量
    let count = 0;
    //递归函数dfs
    function dfs(row, col) {
        //越界条件，如果越界或者当前值为‘0’，则直接返回
        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == 0) {
            return;
        }
        //岛屿数量加一
        count ++;
        // 否则，当前值设为0，判断上下左右的值是否是‘1’
        grid[row][col] = 0
        dfs(row - 1, col)
        dfs(row + 1, col)
        dfs(row, col - 1)
        dfs(row, col + 1)
        // 比较当前岛屿数量和之前的最大岛屿数量取最大值
        maxcount = Math.max(maxcount,count)
    }
    //循环遍历数组，找到值为‘1’的坐标，调用递归函数，如果存在count加一
    for (let row = 0; row<grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] == 1) {
                dfs(row, col)
                count = 0;
            }
        }
    }
    return maxcount;
};
```



