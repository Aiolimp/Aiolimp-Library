###  水果成篮

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

**示例:1**

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

**示例:2**

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

**示例:3**

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

**示例:4**

```
示例 4：

输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

### 思路：滑动窗口

   根据题意需要找到，连续切只有两种数类型的最大值。类似于leetCode第三题，[无重复字符的最长字串](https://github.com/Aiolimp/leetcode/blob/master/leetcode/0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2.md)。

### 代码

```js
var totalFruit = function (fruits) {
    // 定义map，key是当前的数值，value：当前值对应的下标（后面删除当前值需要用到）
    const map = new Map();
    // 定义变量j和最大值max
    let j = 0, max = 1
    for (let i = 0; i < fruits.length; i++) {
        // 将key:当前值，value：当前值的下标放入map中
        map.set(fruits[i], i)
        //如果map的长度大于二，则不符合题意，需要删除map的第一个值
        if (map.size > 2) {
            //定义一个最大值，为数组的最后一个下标
            let minIndex = fruits.length - 1
            // 下面循环为了找到map第一个值对应的value
            for (let [fruits, index] of map) {
                // [fruits, index]解构赋值，index对应map中的value，既数组下标
                if (index < minIndex) {
                    minIndex = index
                }
            }
            // 找到最小的下标就是需要删除map对应值的最后一个值
            map.delete(fruits[minIndex])
            // 删除完毕后，j移动到删除后的值
            j = minIndex + 1;
        }
        //取最大值
        max = Math.max(max, i - j + 1)
    }
    return max
};
```



