###  图像渲染

有一幅以 `m x n` 的二维整数数组表示的图画 `image` ，其中 `image[i][j]` 表示该图画的像素值大小。

你也被给予三个整数 `sr` , `sc` 和 `newColor` 。你应该从像素 `image[sr][sc]` 开始对图像进行 上色**填充** 。

为了完成 **上色工作** ，从初始像素开始，记录初始坐标的 **上下左右四个方向上** 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 **四个方向上** 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 `newColor` 。

最后返回 *经过上色渲染后的图像* 。

**示例:1**

![img](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)

```
输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。
```

**示例:2**

```
输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
输出: [[2,2,2],[2,2,2]]
```

### 思路：



### 代码

```js
var floodFill = function(image, sr, sc, color) {
    // 如果初始点和color相同，则不需要渲染颜色
    if(image[sr][sc] === color) {
        return image
    }
    // 存储初始点
    let oldColor = image[sr][sc]
    function dfs(sr, sc) {
        // 不满足边界条件，或者不等于初始点，直接return
        if (sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] !== oldColor) {
            return
        }
        // 渲染颜色
        image[sr][sc] = color
        //判断当前点的上下左右四个点是否是相连的点
        dfs(sr - 1, sc)
        dfs(sr + 1, sc)
        dfs(sr, sc - 1)
        dfs(sr, sc + 1)
    }
    dfs(sr, sc)
    return image
};
```



