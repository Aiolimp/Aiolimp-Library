### 岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

### 思路:

1. 定义岛屿数量`count`，初始值为0；
1. 遍历二维数组，如果某个值等于`‘1’`，则调用`dfs`函数，传入当前值的坐标，`count`加一。
1. 将传入的坐标值设为`‘0’`，递归检查坐标值上下左右对应的值是否为`‘1’`，如果是，则变成0 。

### 代码

```js
var numIslands = function (grid) {
    //定义岛屿数量count，初始值为0；
    let count = 0;
    //递归函数dfs
    function dfs(row, col) {
        //越界条件，如果越界或者当前值为‘0’，则直接返回
        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] === '0') {
            return
        }
        // 否则，当前值设为0，判断上下左右的值是否是‘1’
        grid[row][col] = '0';
        dfs(row + 1, col)
        dfs(row - 1, col)
        dfs(row, col + 1)
        dfs(row, col - 1)
    }
    //循环遍历数组，找到值为‘1’的坐标，调用递归函数，如果存在count加一
    for (let row = 0; row < grid.length; row++) {
        for (let col = 0; col < grid[0].length; col++) {
            if (grid[row][col] === '1') {
                count++;
                dfs(row, col)
            }
        }
    }
    return count
};
```



